# Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов.
# Результаты анализа сохранить в виде комментариев в файле с кодом:


# Без использования Решета Эратосфена:
# Вариант_1
import time

n = int(input('Enter natural num: '))  # Ввод числа
start = time.time()
sim_list = []  # Создание пустого списка для дальнейшего хранения простых чисел
del_ = 0  # делитель, понадобится для хранения числа делителей числа в цикле
for i in range(2, n + 1):  # Перебор чисел от 0 до n+1 т.е. по последне включительно
    for j in range(2, i):  # Перебор чисел от 2 до теущего i
        if i % j == 0:  # Если число i делится на j нацело, то добавляем +1 к делителям
            del_ += 1
    if del_ == 0:  # Если делителей не найдено, то число простое и добавляем его в список простых чисел
        sim_list.append(i)
    else:  # Обнуляем делители для дальнейшего перебора ряда чисел
        del_ = 0
finish = time.time()
var_1_time = finish - start

print(sim_list)

"""
Второй вариант, более простой. Если найдем хоть один делитель кроме самого числа, то число точно не простое.
И нет смысла проверять 4 или 6 если число и так делится на 2. Поэтому можно пробегать по списку чисел, добавленных в
sim_list_2 ранее, т.е. по списку 2 и простых чисел:
"""
m = int(input('Enter natural num: '))
start = time.time()
sim_list_2 = []
for i in range(2, m + 1):
    for j in sim_list_2:
        if i % j == 0:
            break
    else:
        sim_list_2.append(i)
finish = time.time()
var_2_time = finish - start

print(sim_list_2)

# Решето Эратосфена:
from math import sqrt

start = time.time()


def erato_sieve(o):
    # o = int(input('Enter natural num: '))
    sim_list_3 = [i for i in range(o + 1)]  # Заполняем список генератором
    sim_list_3[1] = 0  # т.к. второй элемент 1 (не считается простым), то забиваем ее нулем
    i = 2  # и начинаем с третьего элемента
    while i < sqrt(o):  # Нет смысла брать вторую часть списка чисел, если в первой части нет делителя
        if sim_list_3[i] != 0:
            j = i ** 2  # Первое кратное 2 будет в 2 раза больше
            while j <= o:  # Замена составного числа на 0
                sim_list_3[j] = 0
                j += i
        i += 1

    sim_list_3 = [i for i in sim_list_3 if sim_list_3[i] != 0] # Убираем из списка а нули и выводим список простых чисел
    return sim_list_3


finish = time.time()
Erato_sieve_time = finish - start

print(erato_sieve(int(input('Enter natural num: '))))

# print(f'Var_1: {var_1_time :.10f} n = 10000,\nVar_2: {var_2_time :.10f} n = 100000,\n'
#       f'Erato_sieve: {Erato_sieve_time :.10f} n = 1000000')

"""
Сложность алгоритма "Вариант_1" - O(n^3) - самый медленный
Сложность алгоритма "Вариант_2" - O(n^2) - побыстрее
Сложность алгоритма "Решето эратосфена" - O(n log log n) - работает в разы быстрее предыдущих алгоритмов
"""
